                              Map的相关介绍
一、map是什么？
1、关联容器
   关联容器支持高效的关键字查找和访问。主要有两种：map和set

2、map简介
   Map中的元素是 关键字—值 对：关键字起到索引的作用，值则表示与索引相关的数据。它提供一对一的数据处理能力，由于这个特性，它完成有可能在我们处理一对一数据的时候，在编程上提供快速通道。
   （字典就是map的一个典型的例子）
   Map类型的操作由于很像对数组的操作，所以map也叫做“关联数组”。（只是这里的数组下标可以是任意的数据类型。）

3、map的内部结构
   map内部自建一颗红黑树(一种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的。

4、与set的区别
   对于set中的每个元素只包含一个关键字
set表示的是集合的概念。

二、map的相关操作
1、定义
   当定义一个map时，必须即定义关键字类型，又定义键值的类型。、
        即：map < 关键字类型，键值类型 > 该map的名字
   要求：对于有序容器（map，multimap，set，multiset）关键字类型必须定义比较      方法。默认情况下——标准库使用关键字类型的“<”运算符来比较两个关键字。在map中：关键字类型是第一部分的类型。
   定义一个比较操作的时候，需要满足以下性质：（自己发明的称呼，请各位指教）
   。。。。。。。。。。。其实就是map的第三个参数啦。。。。。。。。。。。。。。
         （1）一致性：两个关键字不能同时小于等于对方
         （2）传递性：如果k1<=k2,k2<=k3,那么k1一定小于等于k3
         （3）等价性：如果两个关键字谁都不小于等于对方，那么，称这两个关键字等价。
                     如果两个关键字等价，那么容器视它们相等处理。
补充：pair类型（头文件utility）
      定义：
Pair < T1 , T2 > P          p是一个pair 两个成员类型分别为T1，T2。
           Pair < T1 , T2 > P ( v1 , v2 )  p的两个成员类型分别被v1，v2初始化
           Make_pair ( v1 , v2 );       返回一个用v1和v2初始化的pair
      操作：
           P.first         返回名为first的公有数据成员
           P.second       返回名为second的共有成员
           P1 relop p2     关系运算符按字典需定义
           P1==(!=)p2     当first和second分别相等时两个pair相等
2、操作
   关联容器的额外类型别名：
      Key_type       此容器的关键字类型是
      Mapped_type   每个关键字关联的类型（只用于map）
      Value_type     map：pair < const key_pair ,mapped_pair>
   插入相关操作：
      c.insert(v):         v是value_type类型的对象
      c.emplace(args):    args用来构造一个元素

      c.insert(b,e):       b和e是迭代器表示value_type类型指的范围
      c.insert(il):         il为这种值的花括号列表

      c.insert(p,v):        p为迭代器，指出开始搜索的位置返回一个迭代器。
      c.insert(p,args):     指出具有关键字的元素
3、删除相关操作：
      c.erase(k);          删除每个关键字为k的元素
                         返回删除元素的数量

      c.erase(p);          删除p指向的元素
（必须指向一个存在的元素，不可为c.end()）
 返回一个指向p之后的迭代器

      c.erase(b,c);         删除迭代器b和e之间的所有元素
返回e

4、查找相关操作：（下标）
       C[k]:              返回关键字为k的元素
					若k不存在，则添加一个关键字为k的元素，并对其初始化
       c.at(k):            访问关键字为k的元素，带参数检查，
                         若k不存在，则抛出一个out_of_range的异常
5、查找相关操作：（函数）
       c,find(k):            还回第一个关键字为k的迭代器
                           不存在则返回尾后迭代器
       c.count(k):           返回关键字为k的元素的数量
                           若不允许重复关键字，则返回值仅有0和1
       c.lower_bound(k):     返回第一个指向大于等于k的迭代器
       c.upper_bound(k)     返回第一个指向小于等于k的迭代器
       c.equal_range(k):      返回一个迭代器pair，代表关键字等于k的范围
                           若k不存在，则两个迭代器均为c.end()





三、map的注意事项
map中由于它内部有序，由红黑树保证，因此很多函数执行的时间复杂度都是log2N的，如果用map函数可以实现的功能，而STL  Algorithm也可以完成该功能，建议用map自带函数，效率高一些。
map在空间上的特性：由于map的每个数据对应红黑树上的一个节点，这个节点在不保存你的数据时，是占用16个字节的，一个父节点指针，左右孩子指针，还有一个枚举值（标示红黑的，相当于平衡二叉树中的平衡因子），这些地方会很费内存。
根据key值快速查找记录，查找的复杂度基本是Log(N)，如果有1000个记录，最
多查找10次，1,000,000个记录，最多查找20次。
